В JS все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
Исторически наследование выглядит так (а неследование в классах через extends это лишь синтаксический "сахар"):
Функции-конструкторы имеют свойство prototype, в которое записываются свойства и методы.
function Animal(name) {this.name = name;}; Animal.prototype.eat = function () {console.log(`${this.name} eats`);}; function Cat(name) {Animal.call(this, name);}; Cat.prototype = Object.create(Animal.prototype); последняя строка создаёт новый объект, прототипом которого является Animal.prototype. Теперь все методы, определённые в Animal.prototype будут доступны экземплярам Cat через цепочку прототипов.
Cat.prototype.constructor = Cat; - а эта строка исправляет ссылку на конструктор, которая была потеряна при замене prototype. Теперь, если создать объект через new Cat(), его свойство constructor будет корректно указывать на Cat, а не на Animal.
const tom = new Cat('Tom');
tom.eat(); // `Tom eats`;


Вское разное

В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
Объект, на который ссылается [[Prototype]], называется «прототипом».
Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

В этой главе мы кратко описали способ задания [[Prototype]] для объектов, создаваемых с помощью функции-конструктора. Позже мы рассмотрим, как можно использовать эту возможность.

Всё достаточно просто. Выделим основные моменты:

Свойство F.prototype (не путать с [[Prototype]]) устанавливает [[Prototype]] для новых объектов при вызове new F().
Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.
В обычных объектах prototype не является чем-то особенным:

let user = {
  name: "John",
  prototype: "Bla-bla" // никакой магии нет - обычное свойство
};
По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".

Современные способы установки и прямого доступа к прототипу это:

Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), и необязательными дескрипторами свойств.
Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте. Как минимум потому, что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.

Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.

Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:

let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.

Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно использовать как «чистые словари», у них нет проблем с использованием строки "__proto__" в качестве ключа.

Ещё методы:

Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.
Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом for..in.