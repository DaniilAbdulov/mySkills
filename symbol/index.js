// Symbol — это примитивный тип данных в JavaScript,
// который представляет собой уникальное и неизменяемое значение.
// Он используется для создания уникальных идентификаторов, особенно в качестве ключей свойств объектов.

// 1. Как создается Symbol?
// Синтаксис:

const symbol1 = Symbol('описание');
// Каждый вызов Symbol() создает новый уникальный символ, даже если описание совпадает.
// Описание — это строка, которая помогает отлаживать код, но не влияет на уникальность.

// Symbol гарантирует уникальность за счет внутреннего механизма генерации идентификаторов.
// При создании Symbol JavaScript генерирует уникальный внутренний идентификатор, который не доступен из кода.
// Даже если два Symbol имеют одинаковое описание, они не равны:

const sym1 = Symbol('id');
const sym2 = Symbol('id');
console.log(Symbol('1') == Symbol('1'));

console.log(sym1 === sym2); // false

// 3. Глобальный реестр Symbol (Symbol.for)
// Если нужно создать Symbol, доступный во всем приложении, можно использовать глобальный реестр:

const globalSym = Symbol.for('ключ');
// Если Symbol с таким ключом уже существует, он возвращается.
// Если нет — создается новый.

console.log(Symbol.for('id') === Symbol.for('id')); // true
//Есть обратный метод, по которому можно получить описание глоабльного символа.
Symbol.keyFor(globalSym); // вернет строку "id".

// 4. Зачем нужны Symbol?
// a) Создание скрытых свойств объекта

const user = {
  name: 'Alex',
  [Symbol('id')]: 123, // свойство не видно в for..in и Object.keys()
};
// Symbol-ключи игнорируются при итерации (for..in, Object.keys(), JSON.stringify()).

// b) Избежание конфликтов имен
// Symbol полезен, когда нужно добавить метаданные в объект, не рискуя перезаписать существующие свойства.

// c) встроенные Symbol
// JavaScript использует Symbol для определения специальных поведений объектов, например,

// Symbol.iterator — делает объект итерируемым.

// Когда цикл for..of запускается, он вызывает этот метод один раз. Этот метод должен вернуть итератор – объект с методом next.
// Дальше for..of работает только с этим возвращённым объектом.
// Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта.
// Результат вызова next() должен иметь вид {done: Boolean, value: any}, где done=true означает,
// что цикл завершён, в противном случае value содержит очередное значение.

const obj = {
  from: 1,
  to: 5,
};

obj[Symbol.iterator] = function () {
  return {
    current: this.from,
    last: this.to,

    next() {
      if (this.current <= this.last) {
        return {done: false, value: this.current++};
      }
      return {done: true};
    },
  };
};

for (const n of obj) {
  console.log(n);
}

//=====short version=====//
/*
Symbol представляет собой уникальное и неизменяемое значение.

const symbol1 = Symbol('описание');
Каждый вызов Symbol() создает новый уникальный символ, даже если описание совпадает.
Описание — это строка, которая помогает отлаживать код, но не влияет на уникальность.

При создании Symbol JavaScript генерирует уникальный внутренний идентификатор, который не доступен из кода. Даже если два Symbol имеют одинаковое описание, они не равны Symbol('1') === Symbol('1')//false

Если нужно создать Symbol, доступный во всем приложении, можно использовать глобальный реестр:
const globalsym1 = Symbol.for('id');
const globalsym2 = Symbol.for('id');
Если Symbol с таким ключом уже существует, он возвращается.
Если нет — создается новый.
globalsym1 === globalsym2; // true
Есть обратный метод, по которому можно получить описание глобального символа.
Symbol.keyFor(globalsym1); вернет строку "id".

Ключевые особенности использования:
- Создание скрытых свойств объекта, которых не видно при итерации
- Избежание конфликтов имен, когда нужно добавить ключ в объект, не рискуя перезаписать существующие свойства.
- Использование встроенных в JS Symbol, например, Symbol.iterator — делает объект итерируемым.
*/
