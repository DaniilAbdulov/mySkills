Деревья

Деревья состоят:
⁃ Корень
⁃ Узлы (вершины)
⁃ Лист (вершина без потомков)
⁃ Уровень (корневой - 0, далее по порядку)

Наиболее распространенным является бинарное дерево. Деревья с максимальным количество в 2 потомка. Каждая вершина содержит в себе (data, ссылку на левую вершину, ссылка на правую вершину).
Строится оно следующим образом. Новые значения добавляются к null вершине. Есть два правила
Если добавляемое значение меньше значения в родительском узле, то новая вершина добавляется в левую ветвь, иначе в правую. Дубли не добавляются.
![текст]('./Снимок экрана 2025-06-14 в 17.55.02.png')
Что это даёт ? Даёт быстрый поиск нужного значения вместо перебора всех значений.
Деревья в идеале должны быть сбалансированы. А таковыми они считаются, если два поддерева от одной вершины отличаются не более чем на один уровень.
Есть несколько методов балансировки деревьев (АВЛ, Красно-черное, расширяющееся).
Если на вход поступают случайные данные, то высока вероятность того, что будет автоматически построено сбалансированное дерево.

Обход деревьев. 0. В ширину. Перебор по уровням с лева на право 0. В глубину. С корневого до листовой вершины - обратно - другая ветвь и т.д
В ширину.

class TreeNode {
constructor(val = 0, left = null, right = null) {
this.val = val;
this.left = left;
this.right = right;
}
}

// Пример дерева:
// 1
// / \
// 2 3
// / \
// 4 5
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

// Пример дерева:
// 1
// / \
// 2 3
// / \
// 4 5

function BFS(root) {
if (!root) return []; // Если дерево пустое

const queue = [root]; // Очередь для BFS
const result = []; // Результат обхода

while (queue.length > 0) {
const node = queue.shift(); // Извлекаем первый узел
result.push(node.val); // Добавляем в результат

    // Добавляем левого и правого потомка (если есть)
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);

}

return result;
}

console.log(BFS(root)); // [1, 2, 3, 4, 5]

В глубину (inOrderTraversal в BaseTree)
На скрине алгоритм L(левое поддерево) N (вершина) R (правое поддерево). Есть и другие, например, RNL

Удаление узлов. Удалние листовго усзла или узла с одним потомком

Удаление узла с двумя потомками. Берется наименьший из потомков и заменяет удаляемый, что бы не нарушать алгоритм построения бинарного дерева
